## Run "Hello World" in LA bare metal

由于 bmbt 是在裸机上直接运行的，那么必须搞清楚程序是怎样在裸机上运行的。按照惯例，从最简单的"Hello World"入手，即在 LA 裸机上运行“Hello World"。当然这里的裸机指的是支持 LA 的 qemu。

### 1. 显示原理

在没有 OS 支持下，程序必须自己操作硬件来完成输出。在现代计算机体系结构下，CPU 与硬件（尤其是块设备）的交互方式往往是内存地址映射，即程序通过对某个内存地址的读写来完成对硬件的读写。比如在 x86 下，CPU 与显示器的交互过程中，显卡被映射到了内存的`0xb8000`（注意是 20 位）处开始的 16KB。往`0xb8000`这段内存写入内容，就能立即显示在屏幕上。**那么在 LA 中显卡被映射到哪个内存地址？**

在显示器的文本模式下，每个字符都占用 2 个字节，第一个字节是 ASCII 码，第二个字节是字符的颜色，其中高 4 位表示背景颜色，低 4 位表示字体颜色。下图表示颜色值。

| 背景颜色 | 字体颜色   |
| :------- | :--------- |
| 0=黑色   | 8=灰色     |
| 1=蓝色   | 9=淡蓝色   |
| 2=绿色   | A=淡绿色   |
| 3=浅绿色 | B=淡浅绿色 |
| 4=红色   | C=淡红色   |
| 5=紫色   | D=淡紫色   |
| 6=黄色   | E=淡黄色   |
| 7=白色   | F=亮白色   |

### 2. 体系结构相关

搞清楚程序怎样才能在裸机上直接运行，我们需要看看 bios 是怎样把内核拉起来的。

先以 x86 为例：

bios 在完成对硬件进行检测，为 OS 准备相关参数之后（大概过程），会把磁盘第一个扇区（512 字节）的内容复制到内存的`0x7c00`处，然后检查内存的`0x7dfe`处（也就是从`0x7c00`开始的第 510 字节）开始的两个字节（510，511 字节）组成的数字是否是`0xaa55`。如果是，那么 bios 认为前 510 字节是一段可执行文件，于是 jump 到`0x7c00`处开始执行这段程序。所以我们写的代码必须小于 511 字节，并且如果有 jump 指令，要链接到`0x7c00`的位置，即让链接器知道，这段代码执行时会被放到`0x7c00`处，要相应调整各个 label 的绝对位置（不懂），这样才能正确使用 jump 指令。

x86 在上电之后，CPU 是在实模式下运行的，即访问的内存地址都是物理内存地址，且操作数都是 16 位的。但是地址总线的宽度是 20 位的，即最大寻址空间为 1M，为了能够用 16 位寄存器访问 20 位地址，x86 将 1M 空间分为多个段，如代码段，数据段等等。每个段用一个寄存器存放其基址。最后的读写地址就是段基址左移 4 位加上偏移量。

那么问题来了：

（1）LA 中这个过程是怎么样的？即 bios 是否也是把磁盘的第一个扇区的内容复制到内存的`0x7c00`处，然后检查 510，511 字节。手册中没有说明。

（2）LA 中有实模式的概念么？有段寄存器么？

### 3. 问题

1. 在 LA 中显卡被映射到哪个内存地址？
2. LA 中 bios 是否也是把磁盘的第一个扇区的内容复制到内存的`0x7c00`处，然后检查 510，511 字？
3. LA 中有实模式的概念么？有段寄存器么？
