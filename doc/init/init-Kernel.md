## LA 内核启动的逐步分析
- arch/loongarch/kernel/head.S
  - 存储 fw 参数，初始化 kernel, 关键的寄存器初始化
  - [x] fw_arg0 为什么从汇编中可以直接访问，废话，这是全局变量啊
- setup_arch
  - 到目前为止，大多数函数都是空的
  - [ ] setup_early_printk : 利用 serial8250 输出，easy
  - cpu_probe : cpuinfo_loongarch 的初始化, 记录一些信息
  - plat_early_init
    - setup_8250_early_printk_port
    - fw_init_cmdline : 利用 head.S 中的 fw_arg0 组装 kenrel cmdline
    - [ ] prom_init_env : 初始化众多关键数值
      - loongson_regaddr_set : 对于 prom 一些信息的初始化
      - list_find : 根据 fw 提供的参数, 解析信息, 初始化三个指针
        - parse_mem
        - parse_vbios
        - parse_screeninfo
      - memblock_and_maxpfn_init : 给 memblock 初始化物理内存
    - parse_cmdline : 进行参数解析
      - [ ] arch_mem_addpart : 物理内存会因为 `_text` 之类的符号地址而修改，为什么之前不去搞定
      - print_memory_map
      - parse_early_param
        - parse_early_options
          - [ ] parse_args : 应该是内核参数
    - init_initrd : 根据内核参数计算出来 initrd 的位置, 然后通过 finalize_initrd 在 memblock 中间预留空间
    - prom_init
      - *set_io_port_base* : 这个不是硬件应该决定的吗? 还是说，硬件是这么决定，然后软件硬编码编码
      - efi_init
        - efi_config_init
        - [ ] efi_config_parse_tables : 解析出现什么，和 acpi 有什么关系
      - acpi_table_upgrade : 利用 initrd 实现更新 acpi
      - acpi_boot_table_init : 和 acpi_boot_init 相同, 都在 arch/loongarch/kernel/acpi/boot.c
        - acpi_table_init
          - acpi_initialize_tables
            - acpi_os_get_root_pointer : 应该是从 efi 的中获取的, 从 /sys/firmware/efi/systab 中间可以知道采用是 acpi20 的
            - acpi_tb_parse_root_table : 上一个函数获取了 rsdp, 从而解析到，具体内容在哪里我是不知道
              - acpi_tb_print_table_header : 这个对应最开始的一堆输出
                - `[    0.000000] ACPI: RSDP 0x00000000FD2F4000 000024 (v02 LOONGS)`
          - [x] acpi_table_initrd_scan
          - [ ] check_multiple_madt
      - [ ] acpi_boot_init : 这个函数似乎是很容易看懂的，因为马上就要进行中断初始化，所以需要从 acpi 中分析出来自己的中断是个什么情况，需要验证一下读去 pch pic 之类的情况
        - [ ] 初始化 arch_acpi_wakeup_start, 但是不知道是做什么用的
        - acpi_process_madt : MADT(Multiple APIC Description Table)
          - [ ] acpi_parse_madt_lapic_entries : 进一步调用 acpi 的标准接口, 在 drivers/acpi/tables.c
            - 哪里™的有 lapic 啊，还是实际上说，这是 lpaic ?
          - acpi_parse_madt_pch_pic_entries
            - acpi_table_parse_madt : 调用过程中，会将 acpi_parse_pch_pic 作为参数, 后者进一步调用 register_pch_pic
      - register_pch_pic : 从 dmesg 看，acpi_boot_init 的调用路径下没有注册上 pic，这是唯一的调用位置
        - `[    0.000000] PCH_PIC[0]: pch_pic_id 0, version 0, address 0xe0010000000, IRQ 64-127`
      - [ ] prom_init_numa_memory : 从 acpi 中读去信息初始化 numa, 似乎即使是不支持 numa 也需要处理 numa 的配置信息 ?
      - [ ] dmi_scan_machine
      - [ ] dmi_set_dump_stack_arch_desc : 似乎解析了 dmi 信息之后，就可以获取 bios 的信息了
      - [ ] efi_runtime_init
      - [ ] register_smp_ops : 检查一下这些注册函数的使用位置
      - loongson_acpi_init
        - irq_create_fwspec_mapping : ??? 这里应该是一个 bug, 在中断系统初始化之前注册这个 acpi 中断
        - [ ] acpi_registers_setup : 写一些寄存器，需要手册的支持
        - [ ] acpi_hw_clear_status : 写一些寄存器，需要手册的支持
    - cpu_report : 显示一些输出信息
    - [ ] arch_mem_init : 存在一些 device tree 的初始化
      - early_init_dt_verify : 校验 initial_boot_params (也就是 dtb 的地址 loongson_fdt_blob)
      - unflatten_and_copy_device_tree : 解析和初始化设备树
    - resource_init : resources 子系统的初始化
    - plat_smp_setup : 调用函数 plat_smp_ops::smp_finish
    - [ ] cpu_cache_init : mips 特有的 cache 初始化，照抄就好了
    - [ ] paging_init :
      - pagetable_init
      - free_area_init_nodes : 内存系统初始化(1) 会调用到 page_alloc.c 中去, 然后进行整个子系统的初始化
    - boot_cpu_trap_init : 完成中断，tlb 相关的初始化
      - 这是 boot 的 cpu 调用的版本，还有一个 nonboot_cpu_trap_init
      - 完成 handler 空间的分配，ebase / refill_ebase / merror_ebase 的初始化
      - tlb_init : tlb handler 的构建以及其他的初始化
- setup_command_line :  建立命令行参数。内核命令行参数可以写在启动配置文件 (boot.cfg 或 grub.cfg) 中，由 BIOS 或者启动器传递给内核[^1]
- setup_per_cpu_areas : percpu 的空间分配
- [ ] build_all_zonelists : 内存系统初始化(2)
- page_alloc_init
  - [ ] page_alloc_cpu_dead : 内存系统初始化(3)
- [ ] parse_early_param : 又调用一次
- trap_init : 调用 set_handler 将各种 exception 入口加以初始化
- vfs_caches_init_early
- mm_init : 好几个函数都是空的
  - kmem_cache_init
- sched_init
- [ ] early_irq_init
  - [ ] init_irq_default_affinity : 最后其作用体现在
  - alloc_desc : 分配了 16 个 irq_desc
  - irq_insert_desc : 插入到 irq_desc_tree 中，而这个是中断最开始的访问的 irq_desc
    - 与之配套的函数 : irq_to_desc
- init_IRQ
  - irq_set_noprobe
  - arch_init_irq
    - setup_IRQ : 这里应该是建立了三个 IRQ 中断控制器的处理
      - loongarch_cpu_irq_init
      - liointc_init
      - extioi_vec_init
        - [ ] irq_domain_alloc_fwnode : domain handle 是怎么回事, 可以通过 domain handle 创建 irq domain
        - irq_domain_create_linear :
        - extioi_init : 初始化一下 ext io 中断控制器的状态，例如，将所有的中断定位到 ip3
        - irq_set_chained_handler_and_data : 将 `LOONGSON_BRIDGE_IRQ` 作为自己的 parent_irq 来传递到这里
          - [ ] 那么，上面一层的 irq_domain 是怎么知道其 handler 是这个，或者说，ip3_irqdispatch 向下调用的时候，其 irq_desc 的 handler 是怎么注册的
        - pch_msi_init
      - of_setup_pch_irqs : 在 extioi 下初始化 apic
    - setup_vi_handler
- timekeeping_init
- time_init
- [ ] perf_event_init
- [ ] call_function_init
- console_init
  - n_tty_init
  - [ ] initcall_from_entry : 似乎有一些调用通过 section 注册的函数的操作
- setup_per_cpu_pageset : 应该是 percpu page 设置
- numa_policy_init
- [ ] acpi_early_init : 调用这三个函数都是 acpi 库提供的标准函数，这些都是 acpi 的初始化，那么之后使用在哪里?
  - acpi_reallocate_root_table
  - acpi_initialize_subsystem
  - acpi_load_tables
- [ ] sched_clock_init
- vfs_caches_init : 前面初始化了 vfs_caches_init 的内容
- pagecache_init
- acpi_subsystem_init
- rest_init

## notes
- parse_mem

[^1]: P66
